ToDoアプリ開発環境を構築するための手順とコードをまとめたマークダウン形式のドキュメントを作成します。
このドキュメントをプロジェクトの README.md などとして保存しておけば、新しいメンバーが参加したときにもスムーズに環境を共有できます。
Dockerによる開発環境構築ガイド (Next.js + Spring Boot + PostgreSQL)
このドキュメントは、Dockerを使用してFrontend (Next.js), Backend (Spring Boot), DB (PostgreSQL) から構成されるToDoアプリケーションの開発環境を構築する手順をまとめたものです。
目標:
開発者ごとに独立した開発環境をコマンド一つで構築できる。
VSCodeと連携し、ホットリロードやデバッグが可能な快適な開発体験を実現する。
FrontendとBackendの開発を柔軟に切り替えられるようにする。
1. プロジェクトのディレクトリ構成
まず、プロジェクト全体のディレクトリ構成を以下のように整えます。
Generated plaintext
my-todo-app/
├── .vscode/          # VSCodeの設定ファイル（任意）
├── backend/          # Spring Bootプロジェクト
│   ├── src/
│   ├── pom.xml
│   └── Dockerfile    # ★ Backend用Dockerfile
├── frontend/         # Next.jsプロジェクト
│   ├── src/
│   ├── package.json
│   └── Dockerfile    # ★ Frontend用Dockerfile
└── docker-compose.yml # ★ 全体を統括するComposeファイル
Use code with caution.
2. Dockerfileの作成
各サービスをコンテナ内で動作させるための設計図（Dockerfile）を作成します。
Backend用 (backend/Dockerfile)
Spring Bootアプリケーションを開発モードで実行するためのDockerfileです。spring-boot-devtoolsによるホットリロードを有効にします。
Generated dockerfile
# ベースイメージとしてJava 17が使える公式イメージを選択
FROM eclipse-temurin:17-jdk-jammy

# 作業ディレクトリを作成・設定
WORKDIR /app

# Maven Wrapperを先にコピーして、依存関係のダウンロードをキャッシュしやすくする
COPY .mvn/ .mvn
COPY mvnw pom.xml ./

# アプリケーションのソースコードをコピー (ボリュームマウントが主役のため、初回ビルド時に使用)
COPY src ./src

# Maven Wrapperに実行権限を付与し、開発モードでSpring Bootを起動
# これにより、コード変更時に自動でアプリケーションが再起動します
CMD ["./mvnw", "spring-boot:run"]
Use code with caution.
Dockerfile
Frontend用 (frontend/Dockerfile)
Next.jsアプリケーションを開発モードで実行するためのDockerfileです。Next.jsのFast Refresh（ホットリフレッシュ）を有効にします。
Generated dockerfile
# ベースイメージとしてNode.js 18が使える公式イメージを選択
FROM node:18-alpine

# 作業ディレクトリを作成・設定
WORKDIR /app

# 依存関係のファイルを先にコピーし、インストールをキャッシュする
COPY package.json package-lock.json* ./
RUN npm install

# アプリケーションのソースコードをコピー (ボリュームマウントが主役)
COPY . .

# Next.jsの開発サーバーが使用するポートを公開
EXPOSE 3000

# 開発サーバーを起動
# これにより、コード変更が即座にブラウザに反映されます
CMD ["npm", "run", "dev"]
Use code with caution.
Dockerfile
3. docker-compose.yml の作成
プロジェクトのルートディレクトリに、すべてのサービスを定義し、連携させるための docker-compose.yml を作成します。
最終版 docker-compose.yml
このファイルには、開発者が任意でコンテナを起動できる profiles 機能と、DB管理ツール pgAdmin が含まれています。
Generated yaml
version: '3.8'

services:
  # 1. Frontendサービス (Next.js) - "frontend" プロファイル
  frontend:
    build:
      context: ./frontend
      dockerfile: Dockerfile
    container_name: my-todo-frontend
    profiles: ["frontend"] # これを指定することで、明示的に指定しない限り起動しない
    ports:
      - "3000:3000"
    volumes:
      # ホストのコード変更をコンテナに即時反映させるためのボリュームマウント
      - ./frontend:/app
      # node_modulesはコンテナ固有のものを使用する設定
      - /app/node_modules
    environment:
      # Next.jsからバックエンドAPIを呼び出すためのURL
      - NEXT_PUBLIC_API_URL=http://localhost:8080
    # backendサービスが起動してからfrontendを起動する
    depends_on:
      - backend
    # 開発中は手動で制御することが多いので明示的にOFF
    restart: "no"

  # 2. Backendサービス (Spring Boot) - "backend" プロファイル
  backend:
    build:
      context: ./backend
      dockerfile: Dockerfile
    container_name: my-todo-backend
    profiles: ["backend"] # これを指定することで、明示的に指定しない限り起動しない
    ports:
      - "8080:8080"
    volumes:
      # ホストのコード変更をコンテナに即時反映させるためのボリュームマウント
      - ./backend:/app
    environment:
      # Spring BootがDBに接続するための情報 (ホスト名はサービス名'db'を指定)
      - SPRING_DATASOURCE_URL=jdbc:postgresql://db:5432/todo_db
      - SPRING_DATASOURCE_USERNAME=user
      - SPRING_DATASOURCE_PASSWORD=password
    # dbサービスが起動してからbackendを起動する
    depends_on:
      - db
    restart: "no"

  # 3. Databaseサービス (PostgreSQL) - デフォルトで起動
  db:
    image: postgres:15
    container_name: my-todo-db
    ports:
      - "5432:5432"
    environment:
      - POSTGRES_DB=todo_db
      - POSTGRES_USER=user
      - POSTGRES_PASSWORD=password
    volumes:
      # DBのデータを永続化するための名前付きボリューム
      - db-data:/var/lib/postgresql/data
    restart: unless-stopped

  # 4. pgAdminサービス - デフォルトで起動
  pgadmin:
    image: dpage/pgadmin4
    container_name: my-pgadmin-container
    environment:
      - PGADMIN_DEFAULT_EMAIL=admin@example.com
      - PGADMIN_DEFAULT_PASSWORD=admin
    ports:
      - "5050:80"
    volumes:
      # pgAdminの設定情報を永続化するための名前付きボリューム
      - pgadmin_data:/var/lib/pgadmin
    depends_on:
      - db
    restart: unless-stopped

# 名前付きボリュームの定義
volumes:
  db-data:
  pgadmin_data:
Use code with caution.
Yaml
4. 開発環境の利用方法
コマンド操作
VSCodeのターミナルなどで、プロジェクトのルートディレクトリに移動して以下のコマンドを実行します。
A. 基本環境（DB + pgAdmin）の起動
profiles を指定しない場合、db と pgadmin のみが起動します。
Generated bash
docker-compose up -d
Use code with caution.
Bash
B. Frontend開発を行う場合
frontend プロファイルを指定します。depends_on の設定により、backend と db も自動で起動します。
Generated bash
# 初回やDockerfile変更時
docker-compose --profile frontend up -d --build

# 2回目以降
docker-compose --profile frontend up -d
Use code with caution.
Bash
C. Backend開発を行う場合
backend プロファイルを指定します。db も自動で起動します。
Generated bash
# 初回やDockerfile変更時
docker-compose --profile backend up -d --build

# 2回目以降
docker-compose --profile backend up -d
Use code with caution.
Bash
D. 全てのサービスを起動する場合
Generated bash
docker-compose --profile frontend --profile backend up -d --build
Use code with caution.
Bash
E. 環境の停止と削除
起動しているサービスに関わらず、全てのコンテナを停止・削除します。
Generated bash
docker-compose down
Use code with caution.
Bash
※DBのデータを完全に削除したい場合は docker-compose down -v を実行します。
pgAdminの使い方
コンテナ起動後、ブラウザで http://localhost:5050 にアクセスします。
ログイン情報:
Email: admin@example.com
Password: admin
ログイン後、「Add New Server」からDBサーバーを登録します。
Host name/address: db （localhostではない点に注意）
Port: 5432
Maintenance database: todo_db
Username: user
Password: password
5. VSCodeとの連携による開発フロー（推奨）
VSCodeを2つ立ち上げ、それぞれのコンテナに接続することで、FrontendとBackendを同時に、かつクリーンな環境で開発できます。
全コンテナを起動
まず、上記 D のコマンドで全てのコンテナをバックグラウンドで起動しておきます。
Generated bash
docker-compose --profile frontend --profile backend up -d --build
Use code with caution.
Bash
Backendコンテナへの接続（VSCode 1つ目）
VSCodeでプロジェクトフォルダを開きます。
F1キーでコマンドパレットを開き、Dev Containers: Attach to Running Container... を選択します。
コンテナリストから my-todo-backend を選択します。
新しいVSCodeウィンドウが開き、Backendコンテナ内に接続されます。このウィンドウはBackend開発専用です。
Frontendコンテナへの接続（VSCode 2つ目）
ファイル > 新規ウィンドウ で新しいVSCodeウィンドウを開きます。
再度、F1キーから Dev Containers: Attach to Running Container... を選択します。
今度はリストから my-todo-frontend を選択します。
別のVSCodeウィンドウが開き、Frontendコンテナ内に接続されます。このウィンドウはFrontend開発専用です。
この方法により、各ウィンドウで適切なVSCode拡張機能だけが動作し、ターミナル操作も明確に分離されるため、非常に快適な開発が可能です